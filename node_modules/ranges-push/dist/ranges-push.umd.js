/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.2.2
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */

"use strict";var rangesPush=(()=>{var d=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,J=Object.prototype.propertyIsEnumerable;var b=(r,n,o)=>n in r?d(r,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[n]=o,p=(r,n)=>{for(var o in n||(n={}))D.call(n,o)&&b(r,o,n[o]);if(w)for(var o of w(n))J.call(n,o)&&b(r,o,n[o]);return r};var _=(r,n)=>{for(var o in n)d(r,o,{get:n[o],enumerable:!0})},W=(r,n,o,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let l of x(n))!D.call(r,l)&&l!==o&&d(r,l,{get:()=>n[l],enumerable:!(s=I(n,l))||s.enumerable});return r};var j=r=>W(d({},"__esModule",{value:!0}),r);var R=(r,n,o)=>(b(r,typeof n!="symbol"?n+"":n,o),o);var k={};_(k,{Ranges:()=>E,defaults:()=>V,version:()=>H});function $(r,n=1){let o="\xA0";function s(e){return Array.from(e).reverse().join("")}function l(e,g,i){let a=i?`
`:"\r",t=i?"\r":`
`;if(!e)return e;let O=0,y=0,c="";for(let u=0,v=e.length;u<v;u++)(e[u]===a||e[u]===t&&e[u-1]!==a)&&y++,`\r
`.includes(e[u])||e[u]===o?(O=0,e[u]===o?c+=e[u]:e[u]===a?y<=g&&(c+=e[u],e[u+1]===t&&(c+=e[u+1],u++)):e[u]===t&&(e==null?void 0:e[u-1])!==a&&y<=g&&(c+=e[u])):(O++,!e[u+1]&&!y&&(c+=" "));return c}if(typeof r=="string"&&r.length){let e=1;typeof+n=="number"&&Number.isInteger(+n)&&+n>=0&&(e=+n);let g="",i="";if(!r.trim())g=r;else if(!r[0].trim()){for(let a=0,t=r.length;a<t;a++)if(r[a].trim()){g=r.slice(0,a);break}}if(r.trim()&&(r.slice(-1).trim()===""||r.slice(-1)===o)){for(let a=r.length;a--;)if(r[a].trim()){i=r.slice(a+1);break}}return`${l(g,e,!1)}${r.trim()}${s(l(s(i),e,!0))}`}return r}var F={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function T(r,n){if(!Array.isArray(r)||!r.length)return r;let o=p(p({},F),n),s,l;if(o.strictlyTwoElementsInRangeArrays&&!r.every((i,a)=>!Array.isArray(i)||i.length!==2?(s=a,l=i.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(r[s],null,4)}) has not two but ${l} elements!`);if(!r.every((i,a)=>!Array.isArray(i)||!Number.isInteger(i[0])||i[0]<0||!Number.isInteger(i[1])||i[1]<0?(s=a,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(r[s],null,4)}) does not consist of only natural numbers!`);let e=r.length**2,g=0;return Array.from(r).sort((i,a)=>(o.progressFn&&(g+=1,o.progressFn(Math.floor(g*100/e))),i[0]===a[0]?i[1]<a[1]?-1:i[1]>a[1]?1:0:i[0]<a[0]?-1:1))}var A="6.2.2";var N={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function S(r,n){function o(t){return!!t&&typeof t=="object"&&!Array.isArray(t)}if(!Array.isArray(r)||!r.length)return null;let s;if(n)if(o(n)){if(s=p(p({},N),n),s.progressFn&&o(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&typeof s.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(![1,2,"1","2"].includes(s.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);if(typeof s.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else s=p({},N);let l=r.filter(t=>Array.isArray(t)).map(t=>[...t]).filter(t=>t[2]!==void 0||t[0]!==t[1]),e,g,i;s.progressFn?e=T(l,{progressFn:t=>{i=Math.floor(t/5),i!==g&&(g=i,s.progressFn(i))}}):e=T(l);let a=e.length-1;for(let t=a;t>0;t--)s.progressFn&&(i=Math.floor((1-t/a)*78)+21,i!==g&&i>g&&(g=i,s.progressFn(i))),(e[t][0]<=e[t-1][0]||!s.joinRangesThatTouchEdges&&e[t][0]<e[t-1][1]||s.joinRangesThatTouchEdges&&e[t][0]<=e[t-1][1])&&(e[t-1][0]=Math.min(e[t][0],e[t-1][0]),e[t-1][1]=Math.max(e[t][1],e[t-1][1]),e[t][2]!==void 0&&(e[t-1][0]>=e[t][0]||e[t-1][1]<=e[t][1])&&e[t-1][2]!==null&&(e[t][2]===null&&e[t-1][2]!==null?e[t-1][2]=null:e[t-1][2]!=null?+s.mergeType==2&&e[t-1][0]===e[t][0]?e[t-1][2]=e[t][2]:e[t-1][2]+=e[t][2]:e[t-1][2]=e[t][2]),e.splice(t,1),t=e.length);return e.length?e:null}var H=A;function m(r){return r!=null}function h(r){return Number.isInteger(r)&&r>=0}function f(r){return typeof r=="string"}var V={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},E=class{constructor(n){R(this,"ranges");R(this,"opts");let o=p(p({},V),n);if(o.mergeType&&o.mergeType!==1&&o.mergeType!==2)if(f(o.mergeType)&&o.mergeType.trim()==="1")o.mergeType=1;else if(f(o.mergeType)&&o.mergeType.trim()==="2")o.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof o.mergeType}", equal to ${JSON.stringify(o.mergeType,null,4)}`);this.opts=o,this.ranges=[]}add(n,o,s){var g;if(n==null&&o==null)return;if(m(n)&&!m(o)){if(Array.isArray(n)){if(n.length){if(n.some(i=>Array.isArray(i))){n.forEach(i=>{Array.isArray(i)&&this.add(...i)});return}n.length&&h(+n[0])&&h(+n[1])&&this.add(...n)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(n,null,0)}) but second-one, "to" is not (${JSON.stringify(o,null,0)})`)}else if(!m(n)&&m(o))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(o,null,0)}) but first-one, "from" is not (${JSON.stringify(n,null,0)})`);let l=+n,e=+o;if(h(s)&&(s=String(s)),h(l)&&h(e)){if(m(s)&&!f(s)&&!h(s))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof s}, equal to:
${JSON.stringify(s,null,4)}`);if(m(this.ranges)&&Array.isArray(this.last())&&l===this.last()[1]){if(this.last()[1]=e,this.last()[2],this.last()[2]!==null&&m(s)){let i=this.last()[2]&&this.last()[2].length&&(!((g=this.opts)!=null&&g.mergeType)||this.opts.mergeType===1)?`${this.last()[2]}${s}`:s;this.opts.limitToBeAddedWhitespace&&(i=$(i,this.opts.limitLinebreaksCount)),f(i)&&!i.length||(this.last()[2]=i)}}else{this.ranges||(this.ranges=[]);let i=s!==void 0&&!(f(s)&&!s.length)?[l,e,s&&this.opts.limitToBeAddedWhitespace?$(s,this.opts.limitLinebreaksCount):s]:[l,e];this.ranges.push(i)}}else throw h(l)&&l>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof e}" equal to: ${JSON.stringify(e,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof l}" equal to: ${JSON.stringify(l,null,4)}`)}push(n,o,s){this.add(n,o,s)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=S(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(n=>m(n[2])?[n[0],n[1],$(n[2],this.opts.limitLinebreaksCount)]:n):this.ranges):null}wipe(){this.ranges=[]}replace(n){if(Array.isArray(n)&&n.length)if(Array.isArray(n[0])&&h(n[0][0]))this.ranges=Array.from(n);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(n[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};return j(k);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.1.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 6.1.2
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
