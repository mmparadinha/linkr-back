/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.2.7
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */

"use strict";var rangesApply=(()=>{var c=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var v=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var T=(s,t,a)=>t in s?c(s,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):s[t]=a,y=(s,t)=>{for(var a in t||(t={}))v.call(t,a)&&T(s,a,t[a]);if(w)for(var a of w(t))R.call(t,a)&&T(s,a,t[a]);return s};var D=(s,t)=>{for(var a in t)c(s,a,{get:t[a],enumerable:!0})},j=(s,t,a,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let l of N(t))!v.call(s,l)&&l!==a&&c(s,l,{get:()=>t[l],enumerable:!(n=x(t,l))||n.enumerable});return s};var A=s=>j(c({},"__esModule",{value:!0}),s);var F={};D(F,{rApply:()=>M,version:()=>W});var S={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function h(s,t){if(!Array.isArray(s)||!s.length)return s;let a=y(y({},S),t),n,l;if(a.strictlyTwoElementsInRangeArrays&&!s.every((o,u)=>!Array.isArray(o)||o.length!==2?(n=u,l=o.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(s[n],null,4)}) has not two but ${l} elements!`);if(!s.every((o,u)=>!Array.isArray(o)||!Number.isInteger(o[0])||o[0]<0||!Number.isInteger(o[1])||o[1]<0?(n=u,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(s[n],null,4)}) does not consist of only natural numbers!`);let r=s.length**2,p=0;return Array.from(s).sort((o,u)=>(a.progressFn&&(p+=1,a.progressFn(Math.floor(p*100/r))),o[0]===u[0]?o[1]<u[1]?-1:o[1]>u[1]?1:0:o[0]<u[0]?-1:1))}var b={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function $(s,t){function a(e){return!!e&&typeof e=="object"&&!Array.isArray(e)}if(!Array.isArray(s)||!s.length)return null;let n;if(t)if(a(t)){if(n=y(y({},b),t),n.progressFn&&a(n.progressFn)&&!Object.keys(n.progressFn).length)n.progressFn=null;else if(n.progressFn&&typeof n.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof n.progressFn}", equal to ${JSON.stringify(n.progressFn,null,4)}`);if(![1,2,"1","2"].includes(n.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof n.mergeType}", equal to ${JSON.stringify(n.mergeType,null,4)}`);if(typeof n.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof n.joinRangesThatTouchEdges}", equal to ${JSON.stringify(n.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else n=y({},b);let l=s.filter(e=>Array.isArray(e)).map(e=>[...e]).filter(e=>e[2]!==void 0||e[0]!==e[1]),r,p,o;n.progressFn?r=h(l,{progressFn:e=>{o=Math.floor(e/5),o!==p&&(p=o,n.progressFn(o))}}):r=h(l);let u=r.length-1;for(let e=u;e>0;e--)n.progressFn&&(o=Math.floor((1-e/u)*78)+21,o!==p&&o>p&&(p=o,n.progressFn(o))),(r[e][0]<=r[e-1][0]||!n.joinRangesThatTouchEdges&&r[e][0]<r[e-1][1]||n.joinRangesThatTouchEdges&&r[e][0]<=r[e-1][1])&&(r[e-1][0]=Math.min(r[e][0],r[e-1][0]),r[e-1][1]=Math.max(r[e][1],r[e-1][1]),r[e][2]!==void 0&&(r[e-1][0]>=r[e][0]||r[e-1][1]<=r[e][1])&&r[e-1][2]!==null&&(r[e][2]===null&&r[e-1][2]!==null?r[e-1][2]=null:r[e-1][2]!=null?+n.mergeType==2&&r[e-1][0]===r[e][0]?r[e-1][2]=r[e][2]:r[e-1][2]+=r[e][2]:r[e-1][2]=r[e][2]),r.splice(e,1),e=r.length);return r.length?r:null}var H=!0,m="Invariant failed";function I(s,t){if(!s){if(H)throw new Error(m);var a=typeof t=="function"?t():t,n=a?"".concat(m,": ").concat(a):m;throw new Error(n)}}var E="6.2.7";var W=E;function M(s,t,a){let n=0,l=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof s!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof s}, equal to: ${JSON.stringify(s,null,4)}`);if(t&&!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(a&&typeof a!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof a}, equal to: ${JSON.stringify(a,null,4)}`);if(!t||!t.filter(i=>i).length)return s;let r;Array.isArray(t)&&Number.isInteger(t[0])&&Number.isInteger(t[1])?r=[Array.from(t)]:r=Array.from(t);let p=r.length,o=0;r.filter(i=>i).forEach((i,g)=>{if(a&&(n=Math.floor(o/p*10),n!==l&&(l=n,a(n))),!Array.isArray(i))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${g}th element not an array: ${JSON.stringify(i,null,4)}, which is ${typeof i}`);if(!Number.isInteger(i[0])){if(!Number.isInteger(+i[0])||+i[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its first element is not an integer, string index, but ${typeof i[0]}, equal to: ${JSON.stringify(i[0],null,4)}.`);r[g][0]=+r[g][0]}if(!Number.isInteger(i[1])){if(!Number.isInteger(+i[1])||+i[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its second element is not an integer, string index, but ${typeof i[1]}, equal to: ${JSON.stringify(i[1],null,4)}.`);r[g][1]=+r[g][1]}o+=1});let u=$(r,{progressFn:i=>{a&&(n=10+Math.floor(i/10),n!==l&&(l=n,a(n)))}});I(u);let e=u.length;if(e>0){let i=s.slice(u[e-1][1]);s=u.reduce((g,q,f,d)=>{a&&(n=20+Math.floor(f/e*80),n!==l&&(l=n,a(n)));let O=f===0?0:d[f-1][1],_=d[f][0];return`${g}${s.slice(O,_)}${d[f][2]||""}`},""),s+=i}return s}return A(F);})();
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.2.2
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.1.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
